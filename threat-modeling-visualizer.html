<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threat Modeling Pipeline - Full Application</title>
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            line-height: 1.6;
        }

        .app-container {
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 300px;
            background: #1a1a1a;
            border-right: 1px solid #2d2d2d;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 20px;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d1b4e 100%);
            border-bottom: 1px solid #2d2d2d;
        }

        .sidebar-header h1 {
            font-size: 1.5em;
            background: linear-gradient(135deg, #8b5cf6 0%, #3b82f6 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        /* Main Content */
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .topbar {
            height: 60px;
            background: #1a1a1a;
            border-bottom: 1px solid #2d2d2d;
            display: flex;
            align-items: center;
            padding: 0 20px;
            justify-content: space-between;
        }

        .content-area {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        /* Pipeline Steps */
        .pipeline-step {
            padding: 15px 20px;
            border-left: 3px solid transparent;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .pipeline-step:hover {
            background: rgba(139, 92, 246, 0.1);
            border-left-color: #8b5cf6;
        }

        .pipeline-step.active {
            background: rgba(139, 92, 246, 0.2);
            border-left-color: #8b5cf6;
        }

        .pipeline-step.completed::after {
            content: '‚úì';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #10b981;
            font-weight: bold;
        }

        .pipeline-step.error::after {
            content: '!';
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: #ef4444;
            font-weight: bold;
            background: rgba(239, 68, 68, 0.2);
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .step-title {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .step-description {
            font-size: 0.9em;
            color: #9ca3af;
        }

        /* Forms */
        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #d1d5db;
        }

        .form-control {
            width: 100%;
            padding: 10px 15px;
            background: #0a0a0a;
            border: 1px solid #374151;
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 0.95em;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: #8b5cf6;
            box-shadow: 0 0 0 3px rgba(139, 92, 246, 0.1);
        }

        /* Buttons */
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            font-size: 0.95em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(139, 92, 246, 0.3);
        }

        .btn-secondary {
            background: #374151;
            color: #e0e0e0;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        /* Cards */
        .card {
            background: #1a1a1a;
            border: 1px solid #2d2d2d;
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #2d2d2d;
        }

        .card-title {
            font-size: 1.2em;
            font-weight: bold;
        }

        /* Data Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th,
        .data-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #2d2d2d;
        }

        .data-table th {
            background: #0a0a0a;
            font-weight: 600;
            color: #d1d5db;
        }

        .data-table tr:hover {
            background: rgba(139, 92, 246, 0.05);
        }

        /* Tags */
        .tag {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 0.85em;
            margin-right: 5px;
        }

        .tag-critical {
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .tag-high {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
            border: 1px solid rgba(251, 191, 36, 0.3);
        }

        .tag-medium {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            border: 1px solid rgba(59, 130, 246, 0.3);
        }

        .tag-low {
            background: rgba(16, 185, 129, 0.2);
            color: #34d399;
            border: 1px solid rgba(16, 185, 129, 0.3);
        }

        /* File Upload */
        .file-upload {
            border: 2px dashed #374151;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .file-upload:hover {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.05);
        }

        .file-upload.dragging {
            border-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }

        /* Loading States */
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 2px solid #374151;
            border-top-color: #8b5cf6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .loading-content {
            background: #1a1a1a;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
        }

        /* Tabs */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 1px solid #374151;
            padding-bottom: 10px;
        }

        .tab {
            padding: 10px 20px;
            background: transparent;
            border: none;
            color: #9ca3af;
            cursor: pointer;
            transition: all 0.3s ease;
            border-bottom: 2px solid transparent;
            border-radius: 6px 6px 0 0;
            font-size: 0.95em;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .tab:hover {
            color: #e0e0e0;
            background: rgba(139, 92, 246, 0.1);
        }

        .tab.active {
            color: #8b5cf6;
            border-bottom-color: #8b5cf6;
            background: rgba(139, 92, 246, 0.1);
        }

        /* Charts */
        .chart-container {
            position: relative;
            height: 300px;
            margin-bottom: 20px;
        }

        /* Flow Diagram */
        .flow-diagram {
            width: 100%;
            height: 400px;
            border: 1px solid #2d2d2d;
            border-radius: 8px;
            background: #0a0a0a;
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #1a1a1a;
            border: 1px solid #374151;
            border-radius: 12px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-close {
            background: none;
            border: none;
            color: #9ca3af;
            font-size: 1.5em;
            cursor: pointer;
        }

        /* Attack Path Visualization */
        .attack-path-viz {
            background: #0a0a0a;
            border: 1px solid #2d2d2d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .path-node {
            fill: #8b5cf6;
            stroke: #fff;
            stroke-width: 2px;
            cursor: pointer;
        }

        .path-node:hover {
            fill: #a78bfa;
        }

        .path-link {
            fill: none;
            stroke: #4b5563;
            stroke-width: 2px;
        }

        .path-link.critical {
            stroke: #ef4444;
        }

        /* Console Output */
        .console {
            background: #000;
            color: #0f0;
            font-family: 'Courier New', monospace;
            padding: 15px;
            border-radius: 6px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.9em;
        }

        .console-line {
            margin-bottom: 5px;
        }

        .console-error {
            color: #f00;
        }

        .console-warning {
            color: #ff0;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                border-right: none;
                border-bottom: 1px solid #2d2d2d;
            }
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // API endpoints - Update these to match your Flask backend
        const API_BASE = 'http://localhost:5000/api';

        // Main App Component
        const ThreatModelingApp = () => {
            const [currentStep, setCurrentStep] = React.useState(0);
            const [pipelineState, setPipelineState] = React.useState({
                steps: [
                    { id: 1, name: 'Upload Document', status: 'pending', data: null },
                    { id: 2, name: 'Extract DFD', status: 'pending', data: null },
                    { id: 3, name: 'Generate Threats', status: 'pending', data: null },
                    { id: 4, name: 'Refine Threats', status: 'pending', data: null },
                    { id: 5, name: 'Analyze Attack Paths', status: 'pending', data: null }
                ],
                currentData: {},
                logs: []
            });
            const [loading, setLoading] = React.useState(false);
            const [activeTab, setActiveTab] = React.useState('overview');
            const [currentOperation, setCurrentOperation] = React.useState('');
            const [showConsole, setShowConsole] = React.useState(true);
            const logEndRef = React.useRef(null);

            // Auto-scroll logs
            React.useEffect(() => {
                if (logEndRef.current) {
                    logEndRef.current.scrollIntoView({ behavior: 'smooth' });
                }
            }, [pipelineState.logs]);

            // Poll for logs when processing
            React.useEffect(() => {
                let interval;
                if (loading) {
                    interval = setInterval(async () => {
                        try {
                            const response = await fetch(`${API_BASE}/logs`);
                            const data = await response.json();
                            if (data.logs && data.logs.length > pipelineState.logs.length) {
                                setPipelineState(prev => ({ ...prev, logs: data.logs }));
                            }
                        } catch (error) {
                            console.error('Failed to fetch logs:', error);
                        }
                    }, 1000);
                }
                return () => clearInterval(interval);
            }, [loading]);

            // File upload handler
            const handleFileUpload = async (files) => {
                const formData = new FormData();
                formData.append('document', files[0]);

                setLoading(true);
                setCurrentOperation('Uploading and extracting text from document...');
                updateStepStatus(0, 'running');
                
                try {
                    addLog('Starting document upload...', 'info');
                    const response = await fetch(`${API_BASE}/upload`, {
                        method: 'POST',
                        body: formData
                    });
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Upload failed');
                    }
                    
                    updateStepStatus(0, 'completed', data);
                    addLog(`Document uploaded successfully: ${data.filename}`, 'success');
                    addLog(`Extracted ${data.text_length} characters`, 'info');
                    
                    // Automatically start step 2
                    setTimeout(() => runStep(1), 1000);
                } catch (error) {
                    updateStepStatus(0, 'error');
                    addLog(`Upload failed: ${error.message}`, 'error');
                    setLoading(false);
                    setCurrentOperation('');
                }
            };

            // Run pipeline step
            const runStep = async (stepIndex) => {
                const step = pipelineState.steps[stepIndex];
                setLoading(true);
                updateStepStatus(stepIndex, 'running');
                
                const stepDescriptions = {
                    1: 'Extracting DFD components from document (this may take 30-60 seconds for LLM processing)...',
                    2: 'Generating threats using STRIDE methodology (this may take 1-2 minutes)...',
                    3: 'Refining threats and removing duplicates...',
                    4: 'Analyzing attack paths and scenarios...'
                };
                
                setCurrentOperation(stepDescriptions[stepIndex] || `Running ${step.name}...`);
                addLog(`Starting: ${step.name}`, 'info');

                try {
                    const startTime = Date.now();
                    
                    const response = await fetch(`${API_BASE}/run-step`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            step: step.id,
                            input: pipelineState.steps[stepIndex - 1]?.data || {}
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (!response.ok) {
                        throw new Error(data.error || 'Step failed');
                    }
                    
                    const duration = ((Date.now() - startTime) / 1000).toFixed(1);
                    updateStepStatus(stepIndex, 'completed', data);
                    addLog(`${step.name} completed in ${duration}s - found ${data.count || 0} items`, 'success');
                    
                    // Automatically run next step if configured
                    if (stepIndex < pipelineState.steps.length - 1 && stepIndex < 2) {
                        setTimeout(() => runStep(stepIndex + 1), 1000);
                    } else {
                        setLoading(false);
                        setCurrentOperation('');
                        addLog('Pipeline completed! You can now review and edit the results.', 'success');
                    }
                } catch (error) {
                    updateStepStatus(stepIndex, 'error');
                    addLog(`${step.name} failed: ${error.message}`, 'error');
                    setLoading(false);
                    setCurrentOperation('');
                }
            };

            // Update step status
            const updateStepStatus = (index, status, data = null) => {
                setPipelineState(prev => {
                    const newSteps = [...prev.steps];
                    newSteps[index] = { ...newSteps[index], status, data };
                    return { ...prev, steps: newSteps };
                });
            };

            // Add log entry
            const addLog = (message, type = 'info') => {
                setPipelineState(prev => ({
                    ...prev,
                    logs: [...prev.logs, { message, type, timestamp: new Date() }]
                }));
            };

            // Update data field
            const updateData = (stepIndex, fieldPath, value) => {
                setPipelineState(prev => {
                    const newSteps = [...prev.steps];
                    const step = newSteps[stepIndex];
                    
                    // Deep update using field path (e.g., "threats.0.impact")
                    const paths = fieldPath.split('.');
                    let current = step.data;
                    
                    for (let i = 0; i < paths.length - 1; i++) {
                        current = current[paths[i]];
                    }
                    
                    current[paths[paths.length - 1]] = value;
                    
                    return { ...prev, steps: newSteps };
                });
                
                // Save to backend
                saveStepData(stepIndex);
            };

            // Save step data to backend
            const saveStepData = async (stepIndex) => {
                const step = pipelineState.steps[stepIndex];
                try {
                    await fetch(`${API_BASE}/save-step`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            step: step.id,
                            data: step.data
                        })
                    });
                    addLog(`Saved ${step.name} data`, 'info');
                } catch (error) {
                    addLog(`Failed to save: ${error.message}`, 'error');
                }
            };

            return (
                <div className="app-container">
                    {/* Sidebar */}
                    <div className="sidebar">
                        <div className="sidebar-header">
                            <h1>üõ°Ô∏è Threat Modeling</h1>
                            <p style={{fontSize: '0.9em', color: '#9ca3af', marginTop: '5px'}}>
                                Pipeline Manager
                            </p>
                        </div>
                        
                        {pipelineState.steps.map((step, index) => (
                            <PipelineStep
                                key={step.id}
                                step={step}
                                index={index}
                                active={currentStep === index}
                                onClick={() => setCurrentStep(index)}
                            />
                        ))}
                        
                        <div style={{padding: '20px'}}>
                            <button 
                                className="btn btn-primary" 
                                style={{width: '100%'}}
                                onClick={() => runStep(0)}
                                disabled={loading}
                            >
                                {loading ? 'Running...' : 'Run Full Pipeline'}
                            </button>
                        </div>
                    </div>

                    {/* Main Content */}
                    <div className="main-content">
                        <div className="topbar">
                            <div style={{display: 'flex', gap: '20px'}}>
                                <button 
                                    className={`tab ${activeTab === 'overview' ? 'active' : ''}`}
                                    onClick={() => setActiveTab('overview')}
                                >
                                    Overview
                                </button>
                                <button 
                                    className={`tab ${activeTab === 'edit' ? 'active' : ''}`}
                                    onClick={() => setActiveTab('edit')}
                                >
                                    Edit Data
                                </button>
                                <button 
                                    className={`tab ${activeTab === 'visualize' ? 'active' : ''}`}
                                    onClick={() => setActiveTab('visualize')}
                                >
                                    Visualize
                                </button>
                            </div>
                            
                            <div style={{display: 'flex', gap: '10px', alignItems: 'center'}}>
                                <button 
                                    className="btn btn-secondary btn-sm"
                                    onClick={() => setShowConsole(!showConsole)}
                                >
                                    {showConsole ? 'Hide' : 'Show'} Console
                                </button>
                                <button className="btn btn-secondary">
                                    Export JSON
                                </button>
                            </div>
                        </div>

                        <div className="content-area" style={{paddingBottom: showConsole ? '250px' : '20px'}}>
                            {activeTab === 'overview' && (
                                <OverviewTab 
                                    step={pipelineState.steps[currentStep]}
                                    onUpload={handleFileUpload}
                                    onRunStep={() => runStep(currentStep)}
                                />
                            )}
                            
                            {activeTab === 'edit' && (
                                <EditTab 
                                    step={pipelineState.steps[currentStep]}
                                    onUpdate={(field, value) => updateData(currentStep, field, value)}
                                />
                            )}
                            
                            {activeTab === 'visualize' && (
                                <VisualizeTab 
                                    data={pipelineState}
                                />
                            )}
                        </div>

                        {/* Floating Console */}
                        {showConsole && (
                            <div style={{
                                position: 'fixed',
                                bottom: 0,
                                left: 300,
                                right: 0,
                                height: '250px',
                                background: '#0a0a0a',
                                borderTop: '2px solid #374151',
                                display: 'flex',
                                flexDirection: 'column'
                            }}>
                                <div style={{
                                    padding: '10px 20px',
                                    background: '#1a1a1a',
                                    borderBottom: '1px solid #374151',
                                    display: 'flex',
                                    justifyContent: 'space-between',
                                    alignItems: 'center'
                                }}>
                                    <h3 style={{margin: 0, fontSize: '1em'}}>
                                        Console Output
                                        {loading && (
                                            <span style={{marginLeft: '15px', color: '#8b5cf6'}}>
                                                {currentOperation}
                                            </span>
                                        )}
                                    </h3>
                                    <button 
                                        className="btn btn-secondary btn-sm"
                                        onClick={() => setPipelineState(prev => ({ ...prev, logs: [] }))}
                                    >
                                        Clear
                                    </button>
                                </div>
                                <div className="console" style={{
                                    flex: 1,
                                    overflow: 'auto',
                                    padding: '15px',
                                    fontFamily: 'monospace'
                                }}>
                                    {pipelineState.logs.map((log, index) => (
                                        <div key={index} className={`console-line console-${log.type}`}>
                                            [{new Date(log.timestamp).toLocaleTimeString()}] {log.message}
                                            {log.type === 'info' && loading && index === pipelineState.logs.length - 1 && (
                                                <span className="loading-spinner" style={{
                                                    marginLeft: '10px',
                                                    width: '12px',
                                                    height: '12px',
                                                    display: 'inline-block',
                                                    verticalAlign: 'middle'
                                                }}></span>
                                            )}
                                        </div>
                                    ))}
                                    <div ref={logEndRef} />
                                </div>
                            </div>
                        )}
                    </div>

                    {loading && (
                        <LoadingOverlay currentOperation={currentOperation} />
                    )}
                </div>
            );
        };

        // Pipeline Step Component
        const PipelineStep = ({ step, index, active, onClick }) => {
            const icons = ['üìÑ', 'üîó', '‚ö†Ô∏è', '‚ú®', 'üéØ'];
            
            return (
                <div 
                    className={`pipeline-step ${active ? 'active' : ''} ${step.status}`}
                    onClick={onClick}
                >
                    <div className="step-title">
                        <span>{icons[index]}</span>
                        {step.name}
                    </div>
                    <div className="step-description">
                        {step.status === 'running' && <span className="loading-spinner" />}
                        {step.status === 'completed' && `${step.data?.count || 0} items`}
                        {step.status === 'error' && 'Failed'}
                        {step.status === 'pending' && 'Not started'}
                    </div>
                </div>
            );
        };

        // Overview Tab Component
        const OverviewTab = ({ step, onUpload, onRunStep }) => {
            if (!step) return null;

            if (step.id === 1) {
                return <FileUploadComponent onUpload={onUpload} />;
            }

            return (
                <div className="card">
                    <div className="card-header">
                        <h2 className="card-title">{step.name}</h2>
                        <button 
                            className="btn btn-primary"
                            onClick={onRunStep}
                            disabled={step.status === 'running'}
                        >
                            Run Step
                        </button>
                    </div>
                    
                    {step.data && (
                        <div>
                            <StepSummary step={step} />
                        </div>
                    )}
                </div>
            );
        };

        // Edit Tab Component
        const EditTab = ({ step, onUpdate }) => {
            if (!step || !step.data) {
                return (
                    <div className="card">
                        <p>No data to edit. Run the pipeline first.</p>
                    </div>
                );
            }

            // Different editors based on step
            switch (step.id) {
                case 2: // DFD
                    return <DFDEditor data={step.data} onUpdate={onUpdate} />;
                case 3: // Threats
                case 4: // Refined Threats
                    return <ThreatsEditor data={step.data} onUpdate={onUpdate} />;
                case 5: // Attack Paths
                    return <AttackPathsEditor data={step.data} onUpdate={onUpdate} />;
                default:
                    return <div>Editor not available for this step</div>;
            }
        };

        // Visualize Tab Component
        const VisualizeTab = ({ data }) => {
            const [vizType, setVizType] = React.useState('dfd');

            return (
                <div>
                    <div className="card">
                        <div className="card-header">
                            <h2 className="card-title">Visualizations</h2>
                            <select 
                                className="form-control" 
                                style={{width: '200px'}}
                                value={vizType}
                                onChange={(e) => setVizType(e.target.value)}
                            >
                                <option value="dfd">Data Flow Diagram</option>
                                <option value="threats">Threat Distribution</option>
                                <option value="paths">Attack Paths</option>
                                <option value="risk">Risk Matrix</option>
                            </select>
                        </div>
                        
                        <div className="chart-container">
                            {vizType === 'dfd' && <DFDVisualization data={data.steps[1]?.data} />}
                            {vizType === 'threats' && <ThreatChart data={data.steps[2]?.data} />}
                            {vizType === 'paths' && <AttackPathViz data={data.steps[4]?.data} />}
                            {vizType === 'risk' && <RiskMatrix data={data.steps[3]?.data} />}
                        </div>
                    </div>
                </div>
            );
        };

        // Console Tab Component
        const ConsoleTab = ({ logs }) => {
            const consoleRef = React.useRef(null);
            
            React.useEffect(() => {
                if (consoleRef.current) {
                    consoleRef.current.scrollTop = consoleRef.current.scrollHeight;
                }
            }, [logs]);

            return (
                <div className="card">
                    <div className="card-header">
                        <h2 className="card-title">Console Output</h2>
                        <button className="btn btn-secondary btn-sm">Clear</button>
                    </div>
                    <div className="console" ref={consoleRef}>
                        {logs.map((log, index) => (
                            <div key={index} className={`console-line console-${log.type}`}>
                                [{new Date(log.timestamp).toLocaleTimeString()}] {log.message}
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // File Upload Component
        const FileUploadComponent = ({ onUpload }) => {
            const [dragging, setDragging] = React.useState(false);
            const [inputMethod, setInputMethod] = React.useState('upload');
            const [textContent, setTextContent] = React.useState('');
            const [isProcessing, setIsProcessing] = React.useState(false);

            const handleDrop = (e) => {
                e.preventDefault();
                setDragging(false);
                if (e.dataTransfer.files.length) {
                    onUpload(e.dataTransfer.files);
                }
            };

            const handleTextSubmit = async () => {
                if (!textContent.trim()) {
                    alert('Please enter some text');
                    return;
                }

                setIsProcessing(true);
                
                // Create a Blob from the text content
                const blob = new Blob([textContent], { type: 'text/plain' });
                const file = new File([blob], 'manual_input.txt', { type: 'text/plain' });
                
                // Upload as file
                await onUpload([file]);
                setIsProcessing(false);
            };

            const sampleTexts = {
                ecommerce: `System: E-Commerce Platform
External Entities: User (U), Payment Gateway (PG), Admin (A)
Assets: Customer Database (DB_C), Product Database (DB_P), Session Store (CACHE)
Processes: Web Server (WS), API Gateway (API), Payment Processor (PP), Admin Portal (AP)
Trust Boundaries: Internet to DMZ, DMZ to Internal Network, Internal to Database Zone
Data Flows:
- From User to Web Server: Login credentials and session tokens, Confidential, HTTPS, JWT Authentication
- From Web Server to API Gateway: API requests with user context, Confidential, HTTPS, mTLS
- From API Gateway to Customer Database: Customer queries and updates, PII, TLS, Database credentials
- From Payment Processor to Payment Gateway: Payment transactions, PCI, HTTPS, API Key authentication
- From Admin to Admin Portal: Administrative commands, Confidential, HTTPS, MFA required`,
                
                healthcare: `System: Healthcare Management System
External Entities: Patient (P), Healthcare Provider (HP), Insurance Company (IC)
Assets: Patient Records Database (DB_PR), Medical Images Store (IMG), Audit Logs (LOGS)
Processes: Patient Portal (PP), Clinical System (CS), Billing System (BS), Integration Engine (IE)
Trust Boundaries: Public Internet to Application Layer, Application to Data Layer, External Partners
Data Flows:
- From Patient to Patient Portal: Health information and appointment requests, PHI, HTTPS, SAML SSO
- From Healthcare Provider to Clinical System: Medical records and prescriptions, PHI, HTTPS, Smart Card Auth
- From Clinical System to Patient Records Database: Patient data storage, PHI, TLS, Encrypted at rest
- From Integration Engine to Insurance Company: Claims data, PHI/PII, HTTPS, OAuth 2.0
- From All Systems to Audit Logs: Compliance logging, Internal, TLS, Service Account`,
                
                financial: `System: Banking Application
External Entities: Customer (C), ATM Network (ATM), Credit Bureau (CB), Regulatory Authority (RA)
Assets: Account Database (DB_ACC), Transaction History (DB_TXN), KYC Documents (DOC)
Processes: Mobile App Backend (MAB), Core Banking System (CBS), Fraud Detection (FD), Reporting Service (RS)
Trust Boundaries: Mobile to Backend, Backend to Core Banking, Core to External Services
Data Flows:
- From Customer to Mobile App Backend: Account access and transactions, PCI/PII, HTTPS, Biometric + PIN
- From Mobile App Backend to Core Banking System: Transaction processing, Confidential, mTLS, Certificate auth
- From Core Banking to Account Database: Account updates, PCI, TLS, Vault-managed credentials
- From Fraud Detection to Transaction History: Pattern analysis queries, Internal, TLS, Read-only access
- From Reporting Service to Regulatory Authority: Compliance reports, Confidential, SFTP, PGP encryption`
            };

            return (
                <div className="card">
                    <div className="card-header">
                        <h2 className="card-title">Input System Description</h2>
                    </div>
                    
                    <div className="tabs" style={{marginBottom: '20px'}}>
                        <button 
                            className={`tab ${inputMethod === 'upload' ? 'active' : ''}`}
                            onClick={() => setInputMethod('upload')}
                        >
                            üìÅ Upload File
                        </button>
                        <button 
                            className={`tab ${inputMethod === 'text' ? 'active' : ''}`}
                            onClick={() => setInputMethod('text')}
                        >
                            ‚úèÔ∏è Enter Text
                        </button>
                        <button 
                            className={`tab ${inputMethod === 'sample' ? 'active' : ''}`}
                            onClick={() => setInputMethod('sample')}
                        >
                            üìã Use Sample
                        </button>
                    </div>

                    {inputMethod === 'upload' && (
                        <div 
                            className={`file-upload ${dragging ? 'dragging' : ''}`}
                            onDrop={handleDrop}
                            onDragOver={(e) => { e.preventDefault(); setDragging(true); }}
                            onDragLeave={() => setDragging(false)}
                            onClick={() => document.getElementById('fileInput').click()}
                        >
                            <input 
                                type="file" 
                                id="fileInput" 
                                style={{display: 'none'}}
                                onChange={(e) => onUpload(e.target.files)}
                                accept=".txt,.pdf,.doc,.docx"
                            />
                            <div style={{fontSize: '3em', marginBottom: '10px'}}>üìÅ</div>
                            <p>Drop files here or click to browse</p>
                            <p style={{fontSize: '0.9em', color: '#9ca3af'}}>
                                Supports: TXT, PDF, DOC, DOCX
                            </p>
                        </div>
                    )}

                    {inputMethod === 'text' && (
                        <div>
                            <div className="form-group">
                                <label className="form-label">System Description</label>
                                <textarea 
                                    className="form-control"
                                    rows={15}
                                    placeholder="Enter your system description here. Include:
- System name and purpose
- External entities (users, external systems)
- Assets (databases, file stores)
- Processes (servers, services)
- Trust boundaries
- Data flows (source to destination, data type, protocol, authentication)"
                                    value={textContent}
                                    onChange={(e) => setTextContent(e.target.value)}
                                />
                            </div>
                            <div style={{marginBottom: '15px'}}>
                                <small style={{color: '#9ca3af'}}>
                                    Tip: Use the format "From X to Y: data description, classification, protocol, auth method" for data flows
                                </small>
                            </div>
                            <button 
                                className="btn btn-primary"
                                onClick={handleTextSubmit}
                                disabled={isProcessing || !textContent.trim()}
                            >
                                {isProcessing ? 'Processing...' : 'Process Text'}
                            </button>
                        </div>
                    )}

                    {inputMethod === 'sample' && (
                        <div>
                            <div className="form-group">
                                <label className="form-label">Select Sample System</label>
                                <select 
                                    className="form-control"
                                    onChange={(e) => setTextContent(sampleTexts[e.target.value] || '')}
                                    defaultValue=""
                                >
                                    <option value="" disabled>Choose a sample...</option>
                                    <option value="ecommerce">E-Commerce Platform</option>
                                    <option value="healthcare">Healthcare Management System</option>
                                    <option value="financial">Banking Application</option>
                                </select>
                            </div>
                            
                            {textContent && (
                                <>
                                    <div className="form-group">
                                        <label className="form-label">Sample Content (Editable)</label>
                                        <textarea 
                                            className="form-control"
                                            rows={12}
                                            value={textContent}
                                            onChange={(e) => setTextContent(e.target.value)}
                                        />
                                    </div>
                                    <button 
                                        className="btn btn-primary"
                                        onClick={handleTextSubmit}
                                        disabled={isProcessing}
                                    >
                                        {isProcessing ? 'Processing...' : 'Use This Sample'}
                                    </button>
                                </>
                            )}
                        </div>
                    )}
                </div>
            );
        };

        // DFD Editor Component
        const DFDEditor = ({ data, onUpdate }) => {
            if (!data || !data.dfd) return null;

            return (
                <div>
                    <div className="card">
                        <div className="card-header">
                            <h2 className="card-title">Edit DFD Components</h2>
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Project Name</label>
                            <input 
                                type="text" 
                                className="form-control"
                                value={data.dfd.project_name || ''}
                                onChange={(e) => onUpdate('dfd.project_name', e.target.value)}
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Industry Context</label>
                            <select 
                                className="form-control"
                                value={data.dfd.industry_context || ''}
                                onChange={(e) => onUpdate('dfd.industry_context', e.target.value)}
                            >
                                <option value="Finance">Finance</option>
                                <option value="Healthcare">Healthcare</option>
                                <option value="Retail">Retail</option>
                                <option value="Technology">Technology</option>
                                <option value="Government">Government</option>
                            </select>
                        </div>
                        
                        <h3>Data Flows</h3>
                        {data.dfd.data_flows?.map((flow, index) => (
                            <div key={index} className="card" style={{marginBottom: '15px'}}>
                                <div className="form-group">
                                    <label className="form-label">Source ‚Üí Destination</label>
                                    <div style={{display: 'flex', gap: '10px'}}>
                                        <input 
                                            type="text" 
                                            className="form-control"
                                            value={flow.source || ''}
                                            onChange={(e) => onUpdate(`dfd.data_flows.${index}.source`, e.target.value)}
                                        />
                                        <span style={{alignSelf: 'center'}}>‚Üí</span>
                                        <input 
                                            type="text" 
                                            className="form-control"
                                            value={flow.destination || ''}
                                            onChange={(e) => onUpdate(`dfd.data_flows.${index}.destination`, e.target.value)}
                                        />
                                    </div>
                                </div>
                                
                                <div className="form-group">
                                    <label className="form-label">Data Classification</label>
                                    <select 
                                        className="form-control"
                                        value={flow.data_classification || ''}
                                        onChange={(e) => onUpdate(`dfd.data_flows.${index}.data_classification`, e.target.value)}
                                    >
                                        <option value="Public">Public</option>
                                        <option value="Internal">Internal</option>
                                        <option value="Confidential">Confidential</option>
                                        <option value="PII">PII</option>
                                        <option value="PHI">PHI</option>
                                        <option value="PCI">PCI</option>
                                    </select>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            );
        };

        // Threats Editor Component
        const ThreatsEditor = ({ data, onUpdate }) => {
            const [selectedThreat, setSelectedThreat] = React.useState(null);

            if (!data || !data.threats) return null;

            return (
                <div>
                    <div className="card">
                        <div className="card-header">
                            <h2 className="card-title">Edit Threats ({data.threats.length})</h2>
                        </div>
                        
                        <table className="data-table">
                            <thead>
                                <tr>
                                    <th>Component</th>
                                    <th>STRIDE</th>
                                    <th>Impact</th>
                                    <th>Likelihood</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody>
                                {data.threats.map((threat, index) => (
                                    <tr key={index}>
                                        <td>{threat.component_name}</td>
                                        <td>{threat.stride_category}</td>
                                        <td>
                                            <span className={`tag tag-${threat.impact.toLowerCase()}`}>
                                                {threat.impact}
                                            </span>
                                        </td>
                                        <td>{threat.likelihood}</td>
                                        <td>
                                            <button 
                                                className="btn btn-secondary btn-sm"
                                                onClick={() => setSelectedThreat(index)}
                                            >
                                                Edit
                                            </button>
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>

                    {selectedThreat !== null && (
                        <ThreatEditModal 
                            threat={data.threats[selectedThreat]}
                            index={selectedThreat}
                            onUpdate={(field, value) => onUpdate(`threats.${selectedThreat}.${field}`, value)}
                            onClose={() => setSelectedThreat(null)}
                        />
                    )}
                </div>
            );
        };

        // Threat Edit Modal
        const ThreatEditModal = ({ threat, index, onUpdate, onClose }) => {
            return (
                <div className="modal show">
                    <div className="modal-content">
                        <div className="modal-header">
                            <h3>Edit Threat #{index + 1}</h3>
                            <button className="modal-close" onClick={onClose}>√ó</button>
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Component</label>
                            <input 
                                type="text" 
                                className="form-control"
                                value={threat.component_name}
                                onChange={(e) => onUpdate('component_name', e.target.value)}
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">STRIDE Category</label>
                            <select 
                                className="form-control"
                                value={threat.stride_category}
                                onChange={(e) => onUpdate('stride_category', e.target.value)}
                            >
                                <option value="S">Spoofing</option>
                                <option value="T">Tampering</option>
                                <option value="R">Repudiation</option>
                                <option value="I">Information Disclosure</option>
                                <option value="D">Denial of Service</option>
                                <option value="E">Elevation of Privilege</option>
                            </select>
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Description</label>
                            <textarea 
                                className="form-control"
                                rows={3}
                                value={threat.threat_description}
                                onChange={(e) => onUpdate('threat_description', e.target.value)}
                            />
                        </div>
                        
                        <div className="form-group">
                            <label className="form-label">Mitigation</label>
                            <textarea 
                                className="form-control"
                                rows={3}
                                value={threat.mitigation_suggestion}
                                onChange={(e) => onUpdate('mitigation_suggestion', e.target.value)}
                            />
                        </div>
                        
                        <div style={{display: 'flex', gap: '10px'}}>
                            <div className="form-group" style={{flex: 1}}>
                                <label className="form-label">Impact</label>
                                <select 
                                    className="form-control"
                                    value={threat.impact}
                                    onChange={(e) => onUpdate('impact', e.target.value)}
                                >
                                    <option value="Critical">Critical</option>
                                    <option value="High">High</option>
                                    <option value="Medium">Medium</option>
                                    <option value="Low">Low</option>
                                </select>
                            </div>
                            
                            <div className="form-group" style={{flex: 1}}>
                                <label className="form-label">Likelihood</label>
                                <select 
                                    className="form-control"
                                    value={threat.likelihood}
                                    onChange={(e) => onUpdate('likelihood', e.target.value)}
                                >
                                    <option value="High">High</option>
                                    <option value="Medium">Medium</option>
                                    <option value="Low">Low</option>
                                </select>
                            </div>
                        </div>
                        
                        <button className="btn btn-primary" onClick={onClose}>
                            Save Changes
                        </button>
                    </div>
                </div>
            );
        };

        // DFD Visualization using D3
        const DFDVisualization = ({ data }) => {
            const svgRef = React.useRef(null);

            React.useEffect(() => {
                if (!data || !data.dfd) return;

                const svg = d3.select(svgRef.current);
                svg.selectAll("*").remove();

                const width = 800;
                const height = 400;
                const nodes = [];
                const links = [];

                // Create nodes from entities, processes, and assets
                data.dfd.external_entities?.forEach((entity, i) => {
                    nodes.push({ id: entity, type: 'entity', x: 100, y: 100 + i * 80 });
                });

                data.dfd.processes?.forEach((process, i) => {
                    nodes.push({ id: process, type: 'process', x: 400, y: 100 + i * 80 });
                });

                data.dfd.assets?.forEach((asset, i) => {
                    nodes.push({ id: asset, type: 'asset', x: 700, y: 100 + i * 80 });
                });

                // Create links from data flows
                data.dfd.data_flows?.forEach(flow => {
                    links.push({
                        source: nodes.find(n => n.id === flow.source),
                        target: nodes.find(n => n.id === flow.destination),
                        classification: flow.data_classification
                    });
                });

                // Draw links
                svg.selectAll(".link")
                    .data(links)
                    .enter().append("line")
                    .attr("class", "path-link")
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                // Draw nodes
                const node = svg.selectAll(".node")
                    .data(nodes)
                    .enter().append("g")
                    .attr("transform", d => `translate(${d.x}, ${d.y})`);

                node.append("circle")
                    .attr("r", 30)
                    .attr("class", "path-node");

                node.append("text")
                    .text(d => d.id)
                    .attr("text-anchor", "middle")
                    .attr("dy", 5)
                    .style("fill", "white")
                    .style("font-size", "12px");

            }, [data]);

            return (
                <svg ref={svgRef} width="100%" height="400" className="flow-diagram"></svg>
            );
        };

        // Threat Distribution Chart
        const ThreatChart = ({ data }) => {
            const canvasRef = React.useRef(null);

            React.useEffect(() => {
                if (!data || !data.threats) return;

                const ctx = canvasRef.current.getContext('2d');
                
                // Count threats by STRIDE category
                const strideCounts = {};
                data.threats.forEach(threat => {
                    strideCounts[threat.stride_category] = (strideCounts[threat.stride_category] || 0) + 1;
                });

                new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Object.keys(strideCounts),
                        datasets: [{
                            label: 'Threats by STRIDE Category',
                            data: Object.values(strideCounts),
                            backgroundColor: '#8b5cf6'
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                labels: { color: '#e0e0e0' }
                            }
                        },
                        scales: {
                            y: {
                                ticks: { color: '#e0e0e0' },
                                grid: { color: '#374151' }
                            },
                            x: {
                                ticks: { color: '#e0e0e0' },
                                grid: { color: '#374151' }
                            }
                        }
                    }
                });
            }, [data]);

            return <canvas ref={canvasRef} />;
        };

        // Loading Overlay
        const LoadingOverlay = ({ currentOperation }) => (
            <div className="loading-overlay">
                <div className="loading-content">
                    <div className="loading-spinner" style={{width: '50px', height: '50px'}}></div>
                    <p style={{marginTop: '20px', fontSize: '1.1em', marginBottom: '10px'}}>Processing...</p>
                    {currentOperation && (
                        <p style={{color: '#9ca3af', fontSize: '0.95em', maxWidth: '400px', textAlign: 'center'}}>
                            {currentOperation}
                        </p>
                    )}
                    <div style={{marginTop: '20px', fontSize: '0.85em', color: '#6b7280'}}>
                        <p>‚è±Ô∏è Expected times:</p>
                        <ul style={{textAlign: 'left', marginTop: '10px'}}>
                            <li>DFD Extraction: 30-60 seconds</li>
                            <li>Threat Generation: 1-2 minutes</li>
                            <li>Quality Refinement: 30-45 seconds</li>
                            <li>Attack Path Analysis: 45-90 seconds</li>
                        </ul>
                    </div>
                </div>
            </div>
        );

        // Render the app
        ReactDOM.render(<ThreatModelingApp />, document.getElementById('root'));
    </script>

    <!-- 
    BACKEND SETUP INSTRUCTIONS:
    
    Create a Flask backend (app.py) with these endpoints:
    
    ```python
    from flask import Flask, request, jsonify
    from flask_cors import CORS
    import subprocess
    import json
    import os
    
    app = Flask(__name__)
    CORS(app)
    
    @app.route('/api/upload', methods=['POST'])
    def upload_document():
        file = request.files['document']
        # Save file and return path
        file_path = f"./uploads/{file.filename}"
        file.save(file_path)
        return jsonify({"status": "success", "path": file_path})
    
    @app.route('/api/run-step', methods=['POST'])
    def run_step():
        data = request.json
        step = data['step']
        input_data = data['input']
        
        # Map steps to Python scripts
        scripts = {
            2: 'info_to_dfds.py',
            3: 'dfd_to_threats.py',
            4: 'improve_threat_quality.py',
            5: 'attack_path_analyzer.py'
        }
        
        if step in scripts:
            # Run the Python script
            result = subprocess.run(
                ['python', scripts[step], '--input', json.dumps(input_data)],
                capture_output=True,
                text=True
            )
            
            # Parse output
            output = json.loads(result.stdout)
            return jsonify(output)
        
        return jsonify({"error": "Invalid step"})
    
    @app.route('/api/save-step', methods=['POST'])
    def save_step():
        data = request.json
        step = data['step']
        step_data = data['data']
        
        # Save to file
        with open(f'./output/step_{step}_data.json', 'w') as f:
            json.dump(step_data, f, indent=2)
        
        return jsonify({"status": "saved"})
    
    if __name__ == '__main__':
        app.run(debug=True)
    ```
    
    To use this application:
    
    1. Save this HTML file
    2. Create the Flask backend (app.py) with the endpoints above
    3. Ensure your Python scripts can accept command-line JSON input
    4. Install dependencies: flask, flask-cors
    5. Run: python app.py
    6. Open this HTML file in a browser
    
    The app will:
    - Upload documents and process them through your pipeline
    - Allow editing of all generated data
    - Save changes back to JSON files
    - Provide visualizations of DFDs, threats, and attack paths
    - Show real-time console output
    -->
</body>
</html>